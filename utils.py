import os
import argparse
import json
import numpy as np
import re
from sklearn.model_selection import KFold

from training.audio_visual_data_loader import TrainLoader, TrainLoaderAudio, TrainLoaderVideo, ValLoader, ValLoaderAudio, ValLoaderVideo
def init_args(args):
    # This layout is inspired by source [1]
    # Directories for data and experiments
    cwd = os.getcwd()
    data_path_AVA = os.path.join(cwd, 'ava_training_data')
    exps_dir = os.path.join(cwd, 'exps')

    # Create 'exps/' directory if it does not exist
    os.makedirs(exps_dir, exist_ok=True)

    # Extract numbers from folders named with 'exp[number]' pattern and find the maximum
    max_num = max(
        (int(re.search(r'exp(\d+)', folder).group(1)) for folder in os.listdir(exps_dir) if re.match(r'exp\d+', folder)),
        default=0
    )

    # Determine the name for the new directory
    new_folder_name = f"exp{max_num + 1}"
    save_path = os.path.join(exps_dir, new_folder_name)

    # Make sure the new directory exists
    if not os.path.exists(save_path):
        os.makedirs(save_path)

    args.data_path_AVA = data_path_AVA
    args.save_path = save_path
    args.model_save_path    = os.path.join(args.save_path, 'model')
    args.score_save_path    = os.path.join(args.save_path, 'score.txt')
    args.trial_path_AVA     = os.path.join(args.data_path_AVA, 'transformed_csvs')
    args.audio_orig_path_AVA = os.path.join(args.data_path_AVA, 'orig_audios')
    args.visual_orig_path_AVA= os.path.join(args.data_path_AVA, 'orig_videos')
    args.audio_path_AVA     = os.path.join(args.data_path_AVA, 'clips_audios')
    args.visual_path_AVA    = os.path.join(args.data_path_AVA, 'clips_videos')
    args.train_trial_AVA    = os.path.join(args.trial_path_AVA, 'train.csv')
    args.train_trial_list_AVA    = os.path.join(args.trial_path_AVA, 'train_video_ids.csv')
    args.mAP_path_AVA = os.path.join(cwd, 'training', 'get_ava_active_speaker_performance.py')

    if args.eval_data_type == 'val':
        args.eval_trial_AVA = os.path.join(args.trial_path_AVA, 'test.csv')
        args.eval_combined = os.path.join(args.trial_path_AVA, 'train_combined.csv')
        args.test_combined = os.path.join(args.trial_path_AVA, 'test_combined.csv')
        args.eval_csv_save = os.path.join(args.save_path, 'test_res.csv') 
        args.test_csv_save = os.path.join(args.save_path, 'test_res.csv') 
        args.eval_scores_csv_save = os.path.join(args.save_path, 'val_res_scores.csv') 
    else:
        args.eval_trial_AVA = os.path.join(args.trial_path_AVA, 'test.csv')
        args.eval_combined = os.path.join(args.trial_path_AVA, 'test_combined.csv')
        args.test_combined = os.path.join(args.trial_path_AVA, 'combined_val.csv') 
        args.eval_csv_save  = os.path.join(args.save_path,     'test_res.csv')
        args.eval_scores_csv_save = os.path.join(args.save_path, 'test_res_scores.csv') 
    
    os.makedirs(args.model_save_path, exist_ok = True)
    os.makedirs(args.data_path_AVA, exist_ok = True)

    return args

def get_loader(args, eval=False, current_fold_video_ids=None):
    # Determine the loader type based on the arguments
    use_audio = hasattr(args, 'use_audio') and args.use_audio
    use_video = hasattr(args, 'use_video') and args.use_video
    
    # Choose the appropriate loader based on the conditions
    if use_audio and use_video:
        loader = TrainLoader if not eval else ValLoader
    elif use_audio and not use_video:
        loader = TrainLoaderAudio if not eval else ValLoaderAudio
    elif not use_audio and use_video:
        loader = TrainLoaderVideo if not eval else ValLoaderVideo
    else:
        raise ValueError("Invalid loader configuration")

    # Initialize and return the loader
    return loader(trial_file_name=args.train_trial_AVA,
                  audio_path=os.path.join(args.audio_path_AVA, 'train'),
                  visual_path=os.path.join(args.visual_path_AVA, 'train'),
                  current_fold_video_ids=current_fold_video_ids,
                  **vars(args))

def get_fold_video_ids(train_video_ids, n_splits=5, shuffle=True, random_seed=42):
    kf = KFold(n_splits=n_splits, shuffle=shuffle, random_state=random_seed)
    
    # Initialize lists to hold the video IDs for each fold's train and validation sets
    fold_video_ids = []

    # Convert list of video IDs to a numpy array for indexing
    video_ids_array = np.array(train_video_ids)
    
    # Iterate over the folds generated by KFold
    for train_idx, val_idx in kf.split(video_ids_array):
        # Map indices back to video IDs
        train_ids_fold = video_ids_array[train_idx]
        val_ids_fold = video_ids_array[val_idx]
        
        # Append the train and validation video IDs for this fold to the list
        fold_video_ids.append((train_ids_fold, val_ids_fold))
    
    return fold_video_ids

def parse_args(defaults_path="default_args.json", args_update={}):
    with open(defaults_path) as f:
        defaults = json.load(f)
    defaults.update(args_update)  # Update defaults with any specified updates

    parser = argparse.ArgumentParser()
    for key, value in defaults.items():
        parser.add_argument(f"--{key}", default=value, type=type(value))
    args = parser.parse_args()
    print(args)
    return args

